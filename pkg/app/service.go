// Copyright 2022 The ILLA Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package app

import (
	"errors"
	"time"

	"github.com/illa-family/builder-backend/internal/repository"

	"go.uber.org/zap"
)

type AppService interface {
	CreateApp(app AppDto) (AppDto, error)
	UpdateApp(app AppDto) (AppDto, error)
	DeleteApp(appID int) error
	GetAllApp() ([]AppDto, error)
	DuplicateApp(appID, userID int) (AppDto, error)
	ReleaseApp(appID int) error
	GetEditingVersion(appID int) (Editor, error)
	GetReleaseVersion(appID int) (Editor, error)
}

type AppServiceImpl struct {
	logger              *zap.SugaredLogger
	appRepository       repository.AppRepository
	userRepository      repository.UserRepository
	kvstateRepository   repository.KVStateRepository
	treestateRepository repository.TreeStateRepository
	actionRepository    repository.ActionRepository
}

var type_array = [8]string{"transformer", "restapi", "graphql", "redis", "mysql", "mariadb", "postgresql", "mongodb"}

type AppDto struct {
	ID              int       `json:"appID"` // generated by database primary key serial
	Name            string    `json:"appName" validate:"required"`
	ReleaseVersion  int       `json:"release_version"`  // release version used for mark the app release version.
	MainlineVersion int       `json:"mainline_version"` // mainline version keep the newest app version in database.
	CreatedBy       int       `json:"-" `
	CreatedAt       time.Time `json:"-"`
	UpdatedBy       int       `json:"-"`
	UpdatedAt       time.Time `json:"updatedAt"`
	ModifiedBy      string    `json:"updatedBy"`
}

type Editor struct {
	AppInfo               AppDto            `json:"appInfo"`
	Actions               []Action          `json:"actions"`
	Components            map[string]string `json:"components"`
	DependenciesState     map[string]string `json:"dependenciesState"`
	ExecutionState        ExecutionState    `json:"executionState"`
	DragShadowState       map[string]string `json:"dragShadowState"`
	DottedLineSquareState map[string]string `json:"dottedLineSquareState"`
	DisplayNameState      []string          `json:"displayNameState"`
}

type ExecutionState struct {
	Result string `json:"result"`
	Error  string `json:"error"`
}

type Action struct {
	ID          int                    `json:"actionId"`
	App         int                    `json:"-"`
	Version     int                    `json:"-"`
	Resource    int                    `json:"resourceId,omitempty"`
	DisplayName string                 `json:"displayName,omitempty"`
	Type        string                 `json:"actionType,omitempty"`
	Template    map[string]interface{} `json:"actionTemplate,omitempty"`
	CreatedAt   time.Time              `json:"createdAt,omitempty"`
	CreatedBy   int                    `json:"createdBy,omitempty"`
	UpdatedAt   time.Time              `json:"updatedAt,omitempty"`
	UpdatedBy   int                    `json:"updatedBy,omitempty"`
}

func NewAppServiceImpl(logger *zap.SugaredLogger, appRepository repository.AppRepository,
	userRepository repository.UserRepository, kvstateRepository repository.KVStateRepository,
	treestateRepository repository.TreeStateRepository, actionRepository repository.ActionRepository) *AppServiceImpl {
	return &AppServiceImpl{
		logger:              logger,
		appRepository:       appRepository,
		userRepository:      userRepository,
		kvstateRepository:   kvstateRepository,
		treestateRepository: treestateRepository,
		actionRepository:    actionRepository,
	}
}

func (impl *AppServiceImpl) CreateApp(app AppDto) (AppDto, error) {
	// init
	app.ReleaseVersion = 0 // the draft version will always be 0, so the release version and mainline version are 0 by default when app init.
	app.MainlineVersion = 0
	app.CreatedAt = time.Now().UTC()
	app.UpdatedAt = time.Now().UTC()
	id, err := impl.appRepository.Create(&repository.App{
		Name:            app.Name,
		ReleaseVersion:  app.ReleaseVersion,
		MainlineVersion: app.MainlineVersion,
		CreatedBy:       app.CreatedBy,
		CreatedAt:       app.CreatedAt,
		UpdatedBy:       app.UpdatedBy,
		UpdatedAt:       app.UpdatedAt,
	})
	if err != nil {
		return AppDto{}, err
	}
	app.ID = id
	userRecord, _ := impl.userRepository.RetrieveByID(app.CreatedBy)
	app.ModifiedBy = userRecord.Nickname
	// create kv_states and tree_states for new app
	_ = impl.initialAllTypeTreeStates(app.ID, app.CreatedBy)
	_ = impl.initialAllTypeKVStates(app.ID, app.CreatedBy)
	return app, nil
}

func (impl *AppServiceImpl) initialAllTypeTreeStates(appID, user int) error {
	// create `root` component
	errC := impl.treestateRepository.Create(&repository.TreeState{
		StateType:          repository.TREE_STATE_TYPE_COMPONENTS,
		ParentNodeRefID:    0,
		ChildrenNodeRefIDs: []int{},
		AppRefID:           appID,
		Version:            repository.APP_EDIT_VERSION,
		Name:               "rootDsl",
		Content:            "",
		CreatedAt:          time.Now().UTC(),
		CreatedBy:          user,
		UpdatedAt:          time.Now().UTC(),
		UpdatedBy:          user,
	})
	// create dependencies state
	errD := impl.treestateRepository.Create(&repository.TreeState{
		StateType:          repository.TREE_STATE_TYPE_DEPENDENCIES,
		ParentNodeRefID:    0,
		ChildrenNodeRefIDs: []int{},
		AppRefID:           appID,
		Version:            repository.APP_EDIT_VERSION,
		Name:               "rootDsl",
		Content:            "",
		CreatedAt:          time.Now().UTC(),
		CreatedBy:          user,
		UpdatedAt:          time.Now().UTC(),
		UpdatedBy:          user})
	// create execution state
	errE1 := impl.treestateRepository.Create(&repository.TreeState{
		StateType:          repository.TREE_STATE_TYPE_EXECUTION,
		ParentNodeRefID:    0,
		ChildrenNodeRefIDs: []int{},
		AppRefID:           appID,
		Version:            repository.APP_EDIT_VERSION,
		Name:               "result",
		Content:            "",
		CreatedAt:          time.Now().UTC(),
		CreatedBy:          user,
		UpdatedAt:          time.Now().UTC(),
		UpdatedBy:          user,
	})
	errE2 := impl.treestateRepository.Create(&repository.TreeState{
		StateType:          repository.TREE_STATE_TYPE_EXECUTION,
		ParentNodeRefID:    0,
		ChildrenNodeRefIDs: []int{},
		AppRefID:           appID,
		Version:            repository.APP_EDIT_VERSION,
		Name:               "error",
		Content:            "",
		CreatedAt:          time.Now().UTC(),
		CreatedBy:          user,
		UpdatedAt:          time.Now().UTC(),
		UpdatedBy:          user,
	})
	if errE1 != nil || errE2 != nil || errD != nil || errC != nil {
		return errors.New("initial tree state failed")
	}
	return nil
}

func (impl *AppServiceImpl) initialAllTypeKVStates(appID, user int) error {
	// create drag shadow state
	errS := impl.kvstateRepository.Create(&repository.KVState{
		StateType: repository.KV_STATE_TYPE_DRAG_SHADOW,
		AppRefID:  appID,
		Version:   repository.APP_EDIT_VERSION,
		Key:       "rootDsl",
		Value:     "",
		CreatedAt: time.Now().UTC(),
		CreatedBy: user,
		UpdatedAt: time.Now().UTC(),
		UpdatedBy: user,
	})
	// create dotted line square state
	errL := impl.kvstateRepository.Create(&repository.KVState{
		StateType: repository.KV_STATE_TYPE_DOTTED_LINE_SQUARE,
		AppRefID:  appID,
		Version:   repository.APP_EDIT_VERSION,
		Key:       "rootDsl",
		Value:     "",
		CreatedAt: time.Now().UTC(),
		CreatedBy: user,
		UpdatedAt: time.Now().UTC(),
		UpdatedBy: user,
	})
	// create displayName state
	errD := impl.kvstateRepository.Create(&repository.KVState{
		StateType: repository.KV_STATE_TYPE_DISPLAY_NAME,
		AppRefID:  appID,
		Version:   repository.APP_EDIT_VERSION,
		Key:       "displayName",
		Value:     "",
		CreatedAt: time.Now().UTC(),
		CreatedBy: user,
		UpdatedAt: time.Now().UTC(),
		UpdatedBy: user,
	})
	if errS != nil || errL != nil || errD != nil {
		return errors.New("initial tree state failed")
	}
	return nil
}

func (impl *AppServiceImpl) UpdateApp(app AppDto) (AppDto, error) {
	app.UpdatedAt = time.Now().UTC()
	if err := impl.appRepository.Update(&repository.App{
		ID:              app.ID,
		Name:            app.Name,
		ReleaseVersion:  app.ReleaseVersion,
		MainlineVersion: app.MainlineVersion,
		CreatedBy:       app.CreatedBy,
		CreatedAt:       app.CreatedAt,
		UpdatedBy:       app.UpdatedBy,
		UpdatedAt:       app.UpdatedAt,
	}); err != nil {
		return AppDto{}, err
	}
	return app, nil
}

func (impl *AppServiceImpl) DeleteApp(appID int) error {
	_ = impl.treestateRepository.DeleteAllTypeTreeStatesByApp(appID)
	_ = impl.kvstateRepository.DeleteAllTypeKVStatesByApp(appID)
	_ = impl.actionRepository.DeleteActionsByApp(appID)
	return impl.appRepository.Delete(appID)
}

func (impl *AppServiceImpl) GetAllApp() ([]AppDto, error) {
	res, err := impl.appRepository.RetrieveAll()
	if err != nil {
		return nil, err
	}
	resDtoSlice := make([]AppDto, 0, len(res))
	for _, value := range res {
		user, _ := impl.userRepository.RetrieveByID(value.UpdatedBy)
		resDtoSlice = append(resDtoSlice, AppDto{
			ID:              value.ID,
			Name:            value.Name,
			ReleaseVersion:  value.ReleaseVersion,
			MainlineVersion: value.MainlineVersion,
			UpdatedAt:       value.UpdatedAt,
			ModifiedBy:      user.Nickname,
		})
	}
	return resDtoSlice, nil
}

func (impl *AppServiceImpl) DuplicateApp(appID, userID int) (AppDto, error) {
	appA, err := impl.appRepository.RetrieveAppByID(appID)
	if err != nil {
		return AppDto{}, err
	}
	appA.ReleaseVersion = 0 // the draft version will always be 0, so the release version and mainline version are 0 by default when app init.
	appA.MainlineVersion = 0
	appA.CreatedAt = time.Now().UTC()
	appA.UpdatedAt = time.Now().UTC()
	appA.CreatedBy = userID
	appA.UpdatedBy = userID
	id, err := impl.appRepository.Create(&repository.App{
		Name:            appA.Name,
		ReleaseVersion:  appA.ReleaseVersion,
		MainlineVersion: appA.MainlineVersion,
		CreatedBy:       appA.CreatedBy,
		CreatedAt:       appA.CreatedAt,
		UpdatedBy:       appA.UpdatedBy,
		UpdatedAt:       appA.UpdatedAt,
	})
	if err != nil {
		return AppDto{}, err
	}
	userRecord, _ := impl.userRepository.RetrieveByID(userID)
	appB := AppDto{
		ID:              id,
		Name:            appA.Name,
		ReleaseVersion:  appA.ReleaseVersion,
		MainlineVersion: appA.MainlineVersion,
		CreatedBy:       appA.CreatedBy,
		CreatedAt:       appA.CreatedAt,
		UpdatedBy:       appA.UpdatedBy,
		UpdatedAt:       appA.UpdatedAt,
		ModifiedBy:      userRecord.Nickname,
	}
	_ = impl.copyAllTreeState(appID, appB.ID, userID)
	_ = impl.copyAllKVState(appID, appB.ID, userID)
	_ = impl.copyActions(appID, appB.ID, userID)
	return appB, nil
}

func (impl *AppServiceImpl) copyAllTreeState(appA, appB, user int) error {
	// get edit version K-V state from database
	treestates, err := impl.treestateRepository.RetrieveAllTypeTreeStatesByApp(appA, repository.APP_EDIT_VERSION)
	if err != nil {
		return err
	}
	// update some fields
	for serial, _ := range treestates {
		treestates[serial].ID = 0
		treestates[serial].AppRefID = appB
		treestates[serial].Version = repository.APP_EDIT_VERSION
		treestates[serial].CreatedBy = user
		treestates[serial].CreatedAt = time.Now().UTC()
		treestates[serial].UpdatedBy = user
		treestates[serial].UpdatedAt = time.Now().UTC()
	}
	// and put them to the database as duplicate
	for _, treestate := range treestates {
		if err := impl.treestateRepository.Create(treestate); err != nil {
			return err
		}
	}
	return nil
}

func (impl *AppServiceImpl) copyAllKVState(appA, appB, user int) error {
	// get edit version K-V state from database
	kvstates, err := impl.kvstateRepository.RetrieveAllTypeKVStatesByApp(appA, repository.APP_EDIT_VERSION)
	if err != nil {
		return err
	}
	// update some fields
	for serial, _ := range kvstates {
		kvstates[serial].ID = 0
		kvstates[serial].AppRefID = appB
		kvstates[serial].Version = repository.APP_EDIT_VERSION
		kvstates[serial].CreatedBy = user
		kvstates[serial].CreatedAt = time.Now().UTC()
		kvstates[serial].UpdatedBy = user
		kvstates[serial].UpdatedAt = time.Now().UTC()
	}
	// and put them to the database as duplicate
	for _, kvstate := range kvstates {
		if err := impl.kvstateRepository.Create(kvstate); err != nil {
			return err
		}
	}
	return nil
}

func (impl *AppServiceImpl) copyActions(appA, appB, user int) error {
	// get edit version K-V state from database
	actions, err := impl.actionRepository.RetrieveActionsByAppVersion(appA, repository.APP_EDIT_VERSION)
	if err != nil {
		return err
	}
	// update some fields
	for serial, _ := range actions {
		actions[serial].ID = 0
		actions[serial].App = appB
		actions[serial].Version = repository.APP_EDIT_VERSION
		actions[serial].CreatedBy = user
		actions[serial].CreatedAt = time.Now().UTC()
		actions[serial].UpdatedBy = user
		actions[serial].UpdatedAt = time.Now().UTC()
	}
	// and put them to the database as duplicate
	for _, action := range actions {
		if _, err := impl.actionRepository.Create(action); err != nil {
			return err
		}
	}
	return nil
}

func (impl *AppServiceImpl) ReleaseApp(appID int) error {
	app, err := impl.appRepository.RetrieveAppByID(appID)
	if err != nil {
		return err
	}
	app.MainlineVersion += 1
	app.ReleaseVersion = app.MainlineVersion
	_ = impl.releaseTreeStateByApp(AppDto{ID: appID, MainlineVersion: app.MainlineVersion})
	_ = impl.releaseKVStateByApp(AppDto{ID: appID, MainlineVersion: app.MainlineVersion})
	_ = impl.releaseActionsByApp(AppDto{ID: appID, MainlineVersion: app.MainlineVersion})
	if err := impl.appRepository.Update(app); err != nil {
		return err
	}
	return nil
}

func (impl *AppServiceImpl) releaseTreeStateByApp(app AppDto) error {
	// get edit version K-V state from database
	treestates, err := impl.treestateRepository.RetrieveAllTypeTreeStatesByApp(app.ID, repository.APP_EDIT_VERSION)
	if err != nil {
		return err
	}
	// set version as mainline version
	for serial, _ := range treestates {
		treestates[serial].Version = app.MainlineVersion
	}
	// and put them to the database as duplicate
	for _, treestate := range treestates {
		if err := impl.treestateRepository.Create(treestate); err != nil {
			return err
		}
	}
	return nil
}

func (impl *AppServiceImpl) releaseKVStateByApp(app AppDto) error {
	// get edit version K-V state from database
	kvstates, err := impl.kvstateRepository.RetrieveAllTypeKVStatesByApp(app.ID, repository.APP_EDIT_VERSION)
	if err != nil {
		return err
	}
	// set version as mainline version
	for serial, _ := range kvstates {
		kvstates[serial].Version = app.MainlineVersion
	}
	// and put them to the database as duplicate
	for _, kvstate := range kvstates {
		if err := impl.kvstateRepository.Create(kvstate); err != nil {
			return err
		}
	}
	return nil
}

func (impl *AppServiceImpl) releaseActionsByApp(app AppDto) error {
	// get edit version K-V state from database
	actions, err := impl.actionRepository.RetrieveActionsByAppVersion(app.ID, repository.APP_EDIT_VERSION)
	if err != nil {
		return err
	}
	// set version as mainline version
	for serial, _ := range actions {
		actions[serial].Version = app.MainlineVersion
	}
	// and put them to the database as duplicate
	for _, action := range actions {
		if _, err := impl.actionRepository.Create(action); err != nil {
			return err
		}
	}
	return nil
}

func (impl *AppServiceImpl) GetEditingVersion(appID int) (Editor, error) {
	editor, err := impl.fetchEditor(appID, false)
	if err != nil {
		return Editor{}, err
	}
	return editor, nil
}

func (impl *AppServiceImpl) GetReleaseVersion(appID int) (Editor, error) {
	editor, err := impl.fetchEditor(appID, true)
	if err != nil {
		return Editor{}, err
	}
	return editor, nil
}

func (impl *AppServiceImpl) fetchEditor(appID int, release bool) (Editor, error) {
	app, err := impl.appRepository.RetrieveAppByID(appID)
	if err != nil {
		return Editor{}, err
	}
	user, _ := impl.userRepository.RetrieveByID(app.UpdatedBy)

	res := Editor{}
	version := 0
	res.AppInfo = AppDto{
		ID:              app.ID,
		Name:            app.Name,
		ReleaseVersion:  app.ReleaseVersion,
		MainlineVersion: app.MainlineVersion,
		UpdatedAt:       app.UpdatedAt,
		ModifiedBy:      user.Nickname,
	}
	if release {
		version = app.ReleaseVersion
	}
	res.Actions, _ = impl.formatActions(appID, version)
	res.Components, _ = impl.formatComponents(appID, version)
	res.DependenciesState, _ = impl.formatDependenciesState(appID, version)
	res.ExecutionState, _ = impl.formatExecutionState(appID, version)
	res.DragShadowState, _ = impl.formatDragShadowState(appID, version)
	res.DottedLineSquareState, _ = impl.formatDottedLineSquareState(appID, version)
	res.DisplayNameState, _ = impl.formatDisplayNameState(appID, version)

	return res, nil
}

func (impl *AppServiceImpl) formatActions(appID, version int) ([]Action, error) {
	res, err := impl.actionRepository.RetrieveActionsByAppVersion(appID, version)
	if err != nil {
		return nil, err
	}

	resSlice := make([]Action, 0, len(res))
	for _, value := range res {
		resSlice = append(resSlice, Action{
			ID:          value.ID,
			Resource:    value.Resource,
			DisplayName: value.Name,
			Type:        type_array[value.Type],
			Template:    value.Template,
			CreatedBy:   value.CreatedBy,
			CreatedAt:   value.CreatedAt,
			UpdatedBy:   value.UpdatedBy,
			UpdatedAt:   value.UpdatedAt,
		})
	}
	return resSlice, nil
}

func (impl *AppServiceImpl) formatComponents(appID, version int) (map[string]string, error) {
	res, err := impl.treestateRepository.RetrieveTreeStatesByApp(appID, repository.TREE_STATE_TYPE_COMPONENTS, version)
	if err != nil {
		return nil, err
	}

	resMap := map[string]string{}
	for _, component := range res {
		resMap[component.Name] = component.Content
	}

	return resMap, nil
}

func (impl *AppServiceImpl) formatDependenciesState(appID, version int) (map[string]string, error) {
	res, err := impl.treestateRepository.RetrieveTreeStatesByApp(appID, repository.TREE_STATE_TYPE_DEPENDENCIES, version)
	if err != nil {
		return nil, err
	}

	resMap := map[string]string{}
	for _, dependency := range res {
		resMap[dependency.Name] = dependency.Content
	}

	return resMap, nil
}

func (impl *AppServiceImpl) formatExecutionState(appID, version int) (ExecutionState, error) {
	res, err := impl.treestateRepository.RetrieveTreeStatesByApp(appID, repository.TREE_STATE_TYPE_EXECUTION, version)
	if err != nil {
		return ExecutionState{}, err
	}

	resE := ExecutionState{}
	for _, item := range res {
		if item.Name == "result" {
			resE.Result = item.Content
		}
		if item.Name == "error" {
			resE.Error = item.Content
		}
	}

	return resE, nil
}

func (impl *AppServiceImpl) formatDragShadowState(appID, version int) (map[string]string, error) {
	res, err := impl.kvstateRepository.RetrieveKVStatesByApp(appID, repository.KV_STATE_TYPE_DRAG_SHADOW, version)
	if err != nil {
		return nil, err
	}

	resMap := map[string]string{}
	for _, shadow := range res {
		resMap[shadow.Key] = shadow.Value
	}

	return resMap, nil
}

func (impl *AppServiceImpl) formatDottedLineSquareState(appID, version int) (map[string]string, error) {
	res, err := impl.kvstateRepository.RetrieveKVStatesByApp(appID, repository.KV_STATE_TYPE_DOTTED_LINE_SQUARE, version)
	if err != nil {
		return nil, err
	}

	resMap := map[string]string{}
	for _, shadow := range res {
		resMap[shadow.Key] = shadow.Value
	}

	return resMap, nil
}

func (impl *AppServiceImpl) formatDisplayNameState(appID, version int) ([]string, error) {
	res, err := impl.kvstateRepository.RetrieveKVStatesByApp(appID, repository.KV_STATE_TYPE_DISPLAY_NAME, version)
	if err != nil {
		return nil, err
	}

	resSlice := []string{}
	for _, displayName := range res {
		resSlice = append(resSlice, displayName.Value)
	}

	return resSlice, nil
}
